<!doctype html>
<meta charset="utf-8" />
<title>Course Outline</title>
<style>
  body{font:14px/1.5 system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";margin:24px;max-width:900px}
  details{margin:4px 0}
  summary{cursor:pointer}
  #meta{color:#555;margin-bottom:12px}
  .count{color:#777;font-size:12px;margin-left:8px}
</style>
<h1 id="title">Course Outline</h1>
<div id="meta"></div>
<div id="tree"></div>
<script id="data" type="application/json">[{"moduleId": "introduction-to-data-structures-and-analysis", "moduleName": "Introduction to Data Structures and Algorithm Analysis", "topics": [{"topicId": "abstract-data-types", "topicName": "Abstract Data Types (ADTs)", "subtopics": [{"subtopicId": "course-goals", "subtopicName": "Data Structures Course Goals and Objectives"}, {"subtopicId": "adt-definition", "subtopicName": "Definition of Abstract Data Types"}, {"subtopicId": "adt-examples", "subtopicName": "Common ADT Examples (Stacks, Queues, Trees, Priority Queues)"}]}, {"topicId": "algorithm-analysis-basics", "topicName": "Fundamentals of Algorithm Analysis", "subtopics": [{"subtopicId": "why-analyze-data-structures", "subtopicName": "Motivation for Analyzing Data Structures"}, {"subtopicId": "time-space-complexity-intro", "subtopicName": "Introduction to Time and Space Complexity"}, {"subtopicId": "machine-compiler-independence", "subtopicName": "Achieving Machine and Compiler Independent Analysis"}, {"subtopicId": "growth-rate-focus", "subtopicName": "Focus on Algorithm Growth Rates"}, {"subtopicId": "big-o-notation-definition", "subtopicName": "Definition of Asymptotic Analysis and Big O Notation"}, {"subtopicId": "interpreting-big-o", "subtopicName": "Understanding Big O as an Upper Bound"}, {"subtopicId": "common-growth-rate-functions", "subtopicName": "Overview of Common Growth Rate Functions (O(1), O(log n), O(n), O(n log n), O(n²), O(n³), O(2^n))"}, {"subtopicId": "big-o-linear-search", "subtopicName": "Big O Analysis of Linear Search"}, {"subtopicId": "big-o-binary-search", "subtopicName": "Big O Analysis of Binary Search"}]}, {"topicId": "list-data-structure", "topicName": "List Data Structure", "subtopics": [{"subtopicId": "list-definition-properties", "subtopicName": "List Data Structure Definition and Properties (Head, Tail)"}, {"subtopicId": "list-operations", "subtopicName": "Fundamental List Operations (Print, Empty, Find, Insert, Remove)"}, {"subtopicId": "array-based-list-limitations", "subtopicName": "Limitations of Array-Based List Implementations"}, {"subtopicId": "linked-list-introduction", "subtopicName": "Introduction to Linked List Implementation Concepts"}]}]}, {"moduleId": "tree-data-structures", "moduleName": "Tree Data Structures", "topics": [{"topicId": "tree-fundamentals", "topicName": "Tree Fundamentals", "subtopics": [{"subtopicId": "tree-recursive-definition", "subtopicName": "Recursive Definition of a Tree"}, {"subtopicId": "basic-tree-terminology", "subtopicName": "Basic Tree Terminology (Root, Child, Parent, Leaf, Sibling)"}, {"subtopicId": "advanced-tree-terminology", "subtopicName": "Advanced Tree Terminology (Path, Length, Depth, Height)"}]}, {"topicId": "binary-trees", "topicName": "Binary Trees", "subtopics": [{"subtopicId": "binary-tree-definition", "subtopicName": "Definition of a Binary Tree"}, {"subtopicId": "binary-tree-structure", "subtopicName": "Binary Tree Node Structure (Element, Left/Right Child References)"}]}, {"topicId": "tree-traversals", "topicName": "Tree Traversals", "subtopics": [{"subtopicId": "conceptual-tree-traversal", "subtopicName": "Conceptual Understanding of Tree Traversal"}, {"subtopicId": "preorder-traversal", "subtopicName": "Preorder Traversal: Definition and Algorithm"}, {"subtopicId": "inorder-traversal", "subtopicName": "Inorder Traversal: Definition and Algorithm"}, {"subtopicId": "postorder-traversal", "subtopicName": "Postorder Traversal: Definition and Algorithm"}, {"subtopicId": "tree-traversal-visualization", "subtopicName": "Visualizing Tree Traversals with Flags"}, {"subtopicId": "reverse-tree-traversals", "subtopicName": "Understanding Reverse Tree Traversals"}]}, {"topicId": "tree-applications", "topicName": "Applications of Trees", "subtopics": [{"subtopicId": "arithmetic-expression-trees", "subtopicName": "Arithmetic Expression Trees (Structure and Components)"}, {"subtopicId": "printing-expression-trees", "subtopicName": "Printing Arithmetic Expressions using Inorder Traversal"}, {"subtopicId": "evaluating-expression-trees", "subtopicName": "Evaluating Arithmetic Expressions using Postorder Traversal"}]}]}, {"moduleId": "balanced-search-trees", "moduleName": "Binary Search Trees and AVL Trees", "topics": [{"topicId": "binary-search-trees", "topicName": "Binary Search Trees (BSTs)", "subtopics": [{"subtopicId": "bst-definition", "subtopicName": "Binary Search Tree Definition and Properties"}, {"subtopicId": "bst-insertion-principle", "subtopicName": "Binary Search Tree Insertion Principle (Adding as Leaf)"}, {"subtopicId": "bst-node-removal-algorithm", "subtopicName": "Binary Search Tree Node Removal Algorithm (Leaf, One Child, Two Children Cases)"}]}, {"topicId": "avl-trees", "topicName": "AVL Trees", "subtopics": [{"subtopicId": "avl-tree-introduction", "subtopicName": "Introduction to AVL Trees: Definition and Balance Property"}, {"subtopicId": "avl-tree-height-definition", "subtopicName": "Definition of Tree Node Height in AVL Context"}, {"subtopicId": "avl-tree-insertion-problem", "subtopicName": "The Imbalance Problem in AVL Tree Insertion"}, {"subtopicId": "types-of-avl-imbalance", "subtopicName": "Identifying Types of AVL Imbalance (Left-Left, Right-Right, Left-Right, Right-Left)"}, {"subtopicId": "localization-rebalancing", "subtopicName": "Localizing Imbalance and Rebalancing Principles"}, {"subtopicId": "single-rotation", "subtopicName": "Single Rotation for Left-Left (and Right-Right) Imbalance"}, {"subtopicId": "double-rotation", "subtopicName": "Double Rotation for Left-Right (and Right-Left) Imbalance"}, {"subtopicId": "avl-insertion-algorithm-logic", "subtopicName": "Conceptual Steps of AVL Tree Insertion Algorithm"}, {"subtopicId": "rotate-with-left-child-method", "subtopicName": "Implementation of rotateWithLeftChild Method"}, {"subtopicId": "rotate-with-right-child-method", "subtopicName": "Implementation of rotateWithRightChild Method"}, {"subtopicId": "double-with-left-child-method", "subtopicName": "Implementation of doubleWithLeftChild Method"}, {"subtopicId": "double-with-right-child-method", "subtopicName": "Implementation of doubleWithRightChild Method"}]}]}, {"moduleId": "priority-queues-and-heaps", "moduleName": "Priority Queues and Heaps", "topics": [{"topicId": "priority-queues", "topicName": "Priority Queues", "subtopics": [{"subtopicId": "priority-queue-definition", "subtopicName": "Definition of a Priority Queue"}, {"subtopicId": "priority-queue-key-property", "subtopicName": "Priority Based on Comparable Values (Keys)"}, {"subtopicId": "priority-queue-applications", "subtopicName": "Real-World Applications of Priority Queues"}, {"subtopicId": "priority-queue-operations", "subtopicName": "Core Priority Queue Operations (Insert, DeleteMin)"}, {"subtopicId": "pq-linked-list-implementation", "subtopicName": "Priority Queue Implementation using Linked Lists (Time Complexity)"}, {"subtopicId": "pq-bst-implementation", "subtopicName": "Priority Queue Implementation using Binary Search Trees (Time Complexity and Limitations)"}]}, {"topicId": "binary-heaps", "topicName": "Binary Heaps", "subtopics": [{"subtopicId": "complete-tree-definition", "subtopicName": "Definition of a Complete Tree"}, {"subtopicId": "heap-order-property", "subtopicName": "Heap Order Property (Minimum Heap)"}, {"subtopicId": "array-representation-of-heap", "subtopicName": "Array Representation of a Binary Heap (Child/Parent Positions)"}, {"subtopicId": "heap-visualization", "subtopicName": "Heap Data Structure Visualization"}]}, {"topicId": "heap-operations", "topicName": "Heap Operations", "subtopics": [{"subtopicId": "heap-insertion-percolate-up", "subtopicName": "Heap Insertion Algorithm (Percolate Up)"}, {"subtopicId": "heap-deletemin-percolate-down", "subtopicName": "Heap Deletion Algorithm (DeleteMin, Percolate Down)"}, {"subtopicId": "heap-operations-time-complexity", "subtopicName": "Time Complexity of Heap Insert and DeleteMin Operations"}]}]}, {"moduleId": "recursion", "moduleName": "Recursion", "topics": [{"topicId": "recursion-basics", "topicName": "Introduction to Recursion", "subtopics": [{"subtopicId": "recursion-definition", "subtopicName": "Definition of Recursion"}, {"subtopicId": "why-use-recursion", "subtopicName": "Advantages and Use Cases of Recursive Methods"}, {"subtopicId": "simple-recursion-example", "subtopicName": "Basic Recursive Program Example (Counting)"}]}, {"topicId": "recursion-visualization-and-design", "topicName": "Visualizing Recursion and Design Principles", "subtopics": [{"subtopicId": "stack-data-structure-overview", "subtopicName": "Overview of the Stack Data Structure (Push/Pop)"}, {"subtopicId": "program-stack-activation-records", "subtopicName": "Understanding the Program Stack and Activation Records"}, {"subtopicId": "visualizing-recursive-calls", "subtopicName": "Visualizing Recursive Calls on the Stack"}, {"subtopicId": "rules-of-recursion", "subtopicName": "Two Fundamental Rules of Recursion (Base Case, Making Progress)"}]}, {"topicId": "recursive-algorithms", "topicName": "Recursive Algorithm Examples", "subtopics": [{"subtopicId": "factorial-definition", "subtopicName": "Factorial Definition (Iterative vs. Recursive Pattern)"}, {"subtopicId": "developing-recursive-factorial", "subtopicName": "Developing a Recursive Solution for Factorial"}, {"subtopicId": "tracing-recursive-factorial", "subtopicName": "Tracing Recursive Factorial Execution with the Stack"}, {"subtopicId": "fibonacci-series-definition", "subtopicName": "Fibonacci Series Definition and Recursive Nature"}, {"subtopicId": "recursive-fibonacci-solution", "subtopicName": "Implementing the Recursive Fibonacci Solution"}, {"subtopicId": "fibonacci-memoization", "subtopicName": "Optimizing Fibonacci with Memoization"}]}, {"topicId": "advanced-recursion-concepts", "topicName": "Advanced Recursion Concepts", "subtopics": [{"subtopicId": "recursion-variations-print-order", "subtopicName": "Impact of Statement Order in Recursive Calls (Variations)"}, {"subtopicId": "common-recursion-errors", "subtopicName": "Common Recursion Errors (Infinite Recursion, StackOverflowError)"}, {"subtopicId": "tail-recursion", "subtopicName": "Definition and Optimization of Tail Recursion"}, {"subtopicId": "converting-tail-recursion-to-iteration", "subtopicName": "Techniques for Converting Tail Recursion to Iteration"}, {"subtopicId": "circular-recursion", "subtopicName": "Understanding and Avoiding Circular Recursion"}]}]}, {"moduleId": "advanced-java-concepts", "moduleName": "Advanced Java Concepts", "topics": [{"topicId": "java-generics", "topicName": "Java Generics", "subtopics": [{"subtopicId": "generics-motivation-arraylist", "subtopicName": "Motivation for Generics (Pre-Java 1.5 vs. Post-Java 1.5 ArrayList)"}, {"subtopicId": "generics-advantages", "subtopicName": "Advantages of Generics (Readability, Type-Safety)"}, {"subtopicId": "formal-type-parameters", "subtopicName": "Understanding Formal Type Parameters"}, {"subtopicId": "generic-class-naming-conventions", "subtopicName": "Naming Conventions for Generic Classes"}, {"subtopicId": "implementing-generic-stack", "subtopicName": "Implementing a Generic Class (Example: Stack<E>)"}, {"subtopicId": "instantiating-generic-classes", "subtopicName": "Instantiating and Using Generic Classes"}]}]}]</script>
<script>
const data = JSON.parse(document.getElementById('data').textContent);
const titleEl = document.getElementById('title');
if (data.course_title) titleEl.textContent = data.course_title;
const metaEl = document.getElementById('meta');
const topCount = (data.outline || []).length;
const src = data.source_file ? `Source: ${data.source_file}` : '';
metaEl.textContent = [src, `Top-level items: ${topCount}`].filter(Boolean).join(' • ');

function make(node) {
  const d = document.createElement('details');
  const s = document.createElement('summary');
  s.textContent = node.label || '';
  d.appendChild(s);
  (node.children || []).forEach(ch => d.appendChild(make(ch)));
  return d;
}

const treeEl = document.getElementById('tree');
(data.outline || []).forEach(n => treeEl.appendChild(make(n)));
</script>
