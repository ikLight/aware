{
    "recursion-mechanics": [
      {
        "stepType": "openQuestion",
        "content": {
          "question": "Imagine you place two mirrors facing each other. What do you see? How is this similar to a function in code calling itself?",
          "placeholder": "Reflect on the infinite depth..."
        }
      },
      {
        "stepType": "lesson",
        "content": {
          "title": "The Call Stack: Anatomy of Recursion",
          "blocks": [
            {
              "type": "text",
              "content": "In standard programming, a method calls another method (e.g., `main()` calls `square()`). In **recursion**, a method calls *itself*.\n\nTo understand how the computer handles this without getting confused, we must look at the **Call Stack** (or Program Stack)."
            },
            {
              "type": "text",
              "content": "**The Stack Metaphor:**\nThink of a stack of trays in a cafeteria. You can only do two things:\n1. **Push:** Place a new tray on top.\n2. **Pop:** Remove the top tray.\n\nEvery time a method is called, an **Activation Record** (or Stack Frame) is **pushed** onto the stack. This record holds the method's local variables and its position. When the method returns, it is **popped**."
            },
            {
              "type": "mermaid",
              "content": "graph TD\n    A[Time 1: main calls count] -->|Push| Stack1[Stack: main]\n    Stack1 -->|count calls itself| Stack2[Stack: main, count]\n    Stack2 -->|count calls itself again| Stack3[Stack: main, count, count]\n    Stack3 -->|Base Case Reached| Pop[Pop frames one by one]"
            }
          ]
        }
      },
      {
        "stepType": "workedExample",
        "content": {
          "title": "Tracing the Stack: The Count Method",
          "blocks": [
            {
              "type": "text",
              "content": "Let's trace the 'World's Simplest Recursion Program' from the lecture to see the stack in action. The goal is to count from 0 to 2."
            },
            {
              "type": "code",
              "language": "java",
              "content": "public static void count(int index) {\n    System.out.print(index);\n    if (index < 2) {\n        count(index + 1); // Recursive call\n    }\n}"
            },
            {
              "type": "text",
              "content": "**State 1: Initial Call**\n`main` calls `count(0)`. The `count(0)` frame is pushed onto the stack. It prints **0**. Since `0 < 2`, it calls `count(1)`."
            },
            {
              "type": "mermaid",
              "content": "graph BT\n    C0[count 0] --> Main[main]"
            },
            {
              "type": "text",
              "content": "**State 2: First Recursive Call**\n`count(1)` is pushed ON TOP of `count(0)`. It prints **1**. Since `1 < 2`, it calls `count(2)`."
            },
            {
              "type": "mermaid",
              "content": "graph BT\n    C1[count 1] --> C0[count 0]\n    C0 --> Main[main]"
            },
            {
              "type": "text",
              "content": "**State 3: Base Case Hit**\n`count(2)` is pushed. It prints **2**. The check `2 < 2` is **FALSE**. No new call is made. `count(2)` returns (Pops)."
            },
            {
              "type": "text",
              "content": "**Unwinding**\nAfter `count(2)` pops, control returns to `count(1)`, which then pops. Then `count(0)` pops. The stack is empty."
            }
          ]
        }
      },
      {
        "stepType": "mcq",
        "content": {
          "question": "What happens if we remove the condition `if (index < 2)` from the `count` method?",
          "options": [
            {
              "id": "A",
              "text": "The program prints nothing.",
              "feedback": "Incorrect. The method would still print the index before making the next call."
            },
            {
              "id": "B",
              "text": "It throws a StackOverflowError.",
              "feedback": "Correct! Without a stopping condition, the method keeps pushing frames until the computer runs out of memory."
            },
            {
              "id": "C",
              "text": "It counts to 100 and stops automatically.",
              "feedback": "Incorrect. Computers do not stop loops automatically unless programmed to do so or they crash."
            }
          ],
          "correctOptionId": "B"
        }
      }
    ],
    "recursive-design-rules": [
      {
        "stepType": "lesson",
        "content": {
          "title": "The Four Rules of Recursion",
          "blocks": [
            {
              "type": "text",
              "content": "According to the Data Structures text, safe recursion follows these rules:"
            },
            {
              "type": "text",
              "content": "1. **Base Case:** You must have a condition that can be solved *without* recursion. This stops the stack from growing forever.\n2. **Making Progress:** Every recursive call must get closer to the Base Case (e.g., `n - 1` or `index + 1`).\n3. **Design Rule:** Assume the recursive call works. Don't try to trace it all in your head at once.\n4. **Compound Interest Rule:** Never duplicate work by solving the same instance of a problem in separate calls (more on this in Fibonacci)."
            },
            {
              "type": "code",
              "language": "java",
              "content": "// BAD RECURSION (Circular)\npublic void bad(int x) {\n    if (x == 0) return;\n    bad(x); // Fails 'Making Progress' rule. x never changes.\n}"
            }
          ]
        }
      },
      {
        "stepType": "codingQuestion",
        "content": {
          "title": "Fix the Infinite Recursion",
          "markdown": "The method below is supposed to countdown from `n` to 0. However, it currently crashes with a `StackOverflowError` because it violates the **Base Case** and **Making Progress** rules.\n\n**Task:**\n1. Add a Base Case to stop when `n` is less than 0.\n2. Fix the recursive call so it makes progress (decrements `n`).",
          "language": "java",
          "starterCode": "import java.util.Scanner;\n\npublic class RecursionFix {\n    public static void countdown(int n) {\n        // TODO: Add Base Case here\n        \n        System.out.println(n);\n        \n        // TODO: Fix the Recursive Call below to make progress\n        countdown(n);\n    }\n\n    public static void main(String[] args) {\n        Scanner s = new Scanner(System.in);\n        int input = s.nextInt();\n        countdown(input);\n    }\n}",
          "solutionCode": "import java.util.Scanner;\n\npublic class RecursionFix {\n    public static void countdown(int n) {\n        // Base Case\n        if (n < 0) return;\n        \n        System.out.println(n);\n        \n        // Making Progress\n        countdown(n - 1);\n    }\n\n    public static void main(String[] args) {\n        Scanner s = new Scanner(System.in);\n        if(s.hasNextInt()) {\n            int input = s.nextInt();\n            countdown(input);\n        }\n    }\n}",
          "testCases": [
            {
              "input": "3",
              "expectedOutput": "3\n2\n1\n0\n",
              "isHidden": false
            },
            {
              "input": "0",
              "expectedOutput": "0\n",
              "isHidden": true
            }
          ]
        }
      }
    ],
    "common-recursive-problems": [
      {
        "stepType": "lesson",
        "content": {
          "title": "Factorials and Tail Recursion",
          "blocks": [
            {
              "type": "text",
              "content": "The classic recursion example is the **Factorial** ($n!$).\n\n$n! = n \\times (n-1)!$\n\nBase Case: $1! = 1$."
            },
            {
              "type": "code",
              "language": "java",
              "content": "public int factorial(int n) {\n    if (n <= 1) return 1;\n    else return n * factorial(n - 1);\n}"
            },
            {
              "type": "text",
              "content": "### Tail Recursion\n**Tail recursion** occurs when the recursive call is the *very last line* of the method. These are easy to convert into `while` loops to save memory.\n\nTo convert:\n1. Enclose the body in a `while` loop.\n2. Replace the recursive call with an update to the parameters."
            }
          ]
        }
      },
      {
        "stepType": "codingQuestion",
        "content": {
          "title": "Implement Recursive Factorial",
          "markdown": "Write a recursive method `findFactorial(int n)` that returns the factorial of `n`.\n\n*   **Formula:** `n! = n * (n-1)!`\n*   **Base Case:** If `n <= 1`, return 1.\n\n**Note:** Do not use loops. Use recursion.",
          "language": "java",
          "starterCode": "import java.util.Scanner;\n\npublic class Factorial {\n    public static long findFactorial(int n) {\n        // Write your recursive logic here\n        return 0; // Placeholder\n    }\n\n    public static void main(String[] args) {\n        Scanner s = new Scanner(System.in);\n        int n = s.nextInt();\n        System.out.print(findFactorial(n));\n    }\n}",
          "solutionCode": "import java.util.Scanner;\n\npublic class Factorial {\n    public static long findFactorial(int n) {\n        if (n <= 1) {\n            return 1;\n        }\n        return n * findFactorial(n - 1);\n    }\n\n    public static void main(String[] args) {\n        Scanner s = new Scanner(System.in);\n        if (s.hasNextInt()) {\n            int n = s.nextInt();\n            System.out.print(findFactorial(n));\n        }\n    }\n}",
          "testCases": [
            {
              "input": "5",
              "expectedOutput": "120",
              "isHidden": false
            },
            {
              "input": "1",
              "expectedOutput": "1",
              "isHidden": true
            },
            {
              "input": "10",
              "expectedOutput": "3628800",
              "isHidden": true
            }
          ]
        }
      },
      {
        "stepType": "workedExample",
        "content": {
          "title": "The Fibonacci Trap (Compound Interest Rule)",
          "blocks": [
            {
              "type": "text",
              "content": "The Fibonacci series (0, 1, 1, 2, 3, 5...) is defined as:\n`fib(n) = fib(n-1) + fib(n-2)`\n\nA naive recursive implementation breaks the **Compound Interest Rule** because it re-solves the same problems over and over."
            },
            {
              "type": "mermaid",
              "content": "graph TD\n    F4[fib 4] --> F3[fib 3]\n    F4 --> F2A[fib 2]\n    F3 --> F2B[fib 2]\n    F3 --> F1A[fib 1]\n    F2A --> F1B[fib 1]\n    F2A --> F0A[fib 0]\n    style F2A fill:#ff9999\n    style F2B fill:#ff9999"
            },
            {
              "type": "text",
              "content": "Notice that `fib(2)` is calculated twice (red nodes). For large `n`, this duplication explodes exponentially. We can fix this using **Memoization** (storing results in an array)."
            }
          ]
        }
      },
      {
        "stepType": "codingQuestion",
        "content": {
          "title": "Optimized Fibonacci (Memoization)",
          "markdown": "The standard recursive Fibonacci is too slow because it repeats work. \n\n**Task:** Implement the `fibonacci` method using the provided `memo` array to store results.\n\n**Logic:**\n1. **Base Cases:** Return `n` if `n` is 0 or 1.\n2. **Check Memo:** If `memo[(int)n]` is not 0, return the stored value immediately.\n3. **Calculate & Store:** If not stored, calculate `fib(n-1) + fib(n-2)`, save it to `memo[(int)n]`, and return it.",
          "language": "java",
          "starterCode": "import java.util.Scanner;\n\npublic class FibMemo {\n    // Array to store calculated values (Memoization)\n    static long[] memo = new long[100];\n\n    public static long fibonacci(long n) {\n        // 1. Base Cases (0 or 1)\n        \n        // 2. Check if already computed in memo\n        \n        // 3. Compute, Store, and Return\n        return 0;\n    }\n\n    public static void main(String[] args) {\n        Scanner s = new Scanner(System.in);\n        long n = s.nextLong();\n        System.out.print(fibonacci(n));\n    }\n}",
          "solutionCode": "import java.util.Scanner;\n\npublic class FibMemo {\n    static long[] memo = new long[100];\n\n    public static long fibonacci(long n) {\n        if (n == 0 || n == 1) {\n            return n;\n        }\n        if (memo[(int)n] != 0) {\n            return memo[(int)n];\n        }\n        \n        memo[(int)n] = fibonacci(n - 1) + fibonacci(n - 2);\n        return memo[(int)n];\n    }\n\n    public static void main(String[] args) {\n        Scanner s = new Scanner(System.in);\n        if(s.hasNextLong()) {\n            long n = s.nextLong();\n            System.out.print(fibonacci(n));\n        }\n    }\n}",
          "testCases": [
            {
              "input": "6",
              "expectedOutput": "8",
              "isHidden": false
            },
            {
              "input": "50",
              "expectedOutput": "12586269025",
              "isHidden": false
            },
            {
              "input": "10",
              "expectedOutput": "55",
              "isHidden": true
            }
          ]
        }
      }
    ]
  }